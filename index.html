<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#1a2a6c">
<link rel="apple-touch-icon" href="ChatGPT Image Oct 5, 2025, 12_37_25 AM.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="GTT">
<title>ÈÉ≠ÂΩ§ÂΩ§</title>
<link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/lxgwwenkai-regular.min.css" rel="stylesheet">
<link rel="preload" as="audio" href="coin-flip-shimmer-85750.mp3" type="audio/mpeg">
<link rel="preload" as="audio" href="tap.mp3" type="audio/mpeg">

<style>
  /* === iOS-compatible dimming overlay === */
  #dim-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    opacity: 0;
    transition: opacity 0.4s ease;
    z-index: 800;
    pointer-events: none;
  }
  
  body.raining #dim-overlay {
    opacity: 1;
  }
  
  #splash-particles {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 9998;
    pointer-events: none;
    opacity: 0.4;
  }
  
  /* ===== RESET & BASE STYLES ===== */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    height: 100%;
    width: 100%;
    background: linear-gradient(135deg, #1a2a6c, #6f5d7a, #25f37b);
    background-size: 400% 400%;
    animation: gradientShift 15s ease infinite;
    margin: 0;
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    min-height: 100vh; /* Fallback for dynamic viewport */
    min-height: calc(102% + env(safe-area-inset-bottom)); /* Extend to cover bottom safe area */
  }

  body {
  height: 100%;
  width: 100%;
  background: inherit; /* Inherit the gradient from html instead of forcing transparent */
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: 'LXGW WenKai', 'Inter', 'PingFang SC', sans-serif;
  overflow: hidden;
  margin: 0;
  -webkit-touch-callout: none;
  -webkit-text-size-adjust: 100%;
  color: #fff8e7;
}

  /* ===== MAIN CONTAINER ===== */
  .main-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    padding: 20px;
  }

  /* ===== CARD COMPONENT ===== */
  .card {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 24px;
    padding: 32px 24px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.12);
    max-width: 420px;
    width: 100%;
    text-align: center;
    position: relative;
    z-index: 10;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .card:hover {
    transform: translateY(-5px);
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
  }

  /* ===== HEADER STYLES ===== */
  .header {
    margin-bottom: 24px;
  }

  .title {
    font-size: 2.2rem;
    font-weight: 500;
    margin-bottom: 12px;
    color: #fff8e7;
    text-shadow: 0 0 10px rgba(255, 248, 231, 0.3);
    letter-spacing: 0.5px;
  }

  .subtitle {
    font-size: 1rem;
    line-height: 1.6;
    opacity: 0.9;
    font-weight: 300;
    max-width: 320px;
    margin: 0 auto;
  }

  /* ===== COIN STYLES ===== */
  .coin-section {
    margin: 24px 0 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .coin-container {
    perspective: 1000px;
    width: 160px;
    height: 160px;
    margin-bottom: 24px;
    position: relative;
  }

  .coin {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1.8s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .coin.flipping {
    animation: flip 1.8s cubic-bezier(0.23, 1, 0.32, 1);
  }

  .coin-face {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    
    /* Enhanced metallic gradient */
    background: radial-gradient(circle at 30% 30%, 
              rgba(255, 255, 255, 0.25) 0%, 
              rgba(255, 255, 255, 0.15) 15%, 
              rgba(255, 255, 255, 0.08) 40%, 
              rgba(255, 255, 255, 0.04) 70%, 
              transparent 100%);
  
  /* Subtle glowing border */
  border: 2px solid rgba(255, 255, 255, 0.3);
    
  
    /* Enhanced shadows */
    box-shadow:
      /* Outer glow */
    0 0 30px rgba(255, 255, 255, 0.4),
    0 0 60px rgba(9, 194, 123, 0.2), /* Tie into page's green accent */
    /* Subtle depth shadows */
    0 8px 20px rgba(0, 0, 0, 0.2),
    inset 0 -8px 20px rgba(0, 0, 0, 0.1),
    inset 0 8px 20px rgba(255, 255, 255, 0.2);
  }

  .coin-face::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.8) 0%, 
                rgba(255, 255, 255, 0.4) 20%, 
                rgba(255, 255, 255, 0.2) 40%, 
                transparent 70%);
    z-index: 1;
    pointer-events: none;
  }

  .coin-face::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, 
                rgba(255, 255, 255, 0.8) 0deg,
                rgba(255, 255, 255, 0.4) 60deg,
                rgba(255, 255, 255, 0.2) 120deg,
                rgba(255, 255, 255, 0.1) 180deg,
                rgba(255, 255, 255, 0.2) 240deg,
                rgba(255, 255, 255, 0.4) 300deg,
                rgba(255, 255, 255, 0.8) 360deg);
    opacity: 0.6;
    animation: spinGleam 4s linear infinite;
    pointer-events: none;
    border-radius: 50%;
    z-index: 2;
  }

  .coin-front {
    transform: rotateY(0deg);
    z-index: 2;
  }

  .coin-back {
    transform: rotateY(180deg);
  }

  .coin-image-container {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    overflow: hidden;
    position: relative;
    z-index: 3;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
  }

  .coin-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .coin-fallback {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
    font-size: 3rem;
    color: #1a2a6c;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
  }

  /* ===== RESULT DISPLAY ===== */
  .result-section {
    margin-bottom: 28px;
    min-height: 70px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .result-text {
    background: rgba(255, 255, 255, 0.12);
    padding: 14px 28px;
    border-radius: 50px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 1.4rem;
    font-weight: 500;
    transition: all 0.3s ease;
    max-width: 280px;
    width: 100%;
  }

  .result-text.celebrate {
    animation: celebrate 0.5s ease;
    background: rgba(255, 255, 255, 0.2);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  }

  /* ===== BUTTON STYLES ===== */
  .btn {
    background: linear-gradient(to right, #fff, #f0f0f0);
    color: #1a2a6c;
    border: none;
    padding: 14px 40px;
    font-size: 1.1rem;
    font-weight: 500;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
    letter-spacing: 0.5px;
    -webkit-tap-highlight-color: transparent;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transition: 0.5s;
  }

  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.25);
  }

  .btn:hover::before {
    left: 100%;
  }

  .btn:active {
    transform: translateY(1px);
  }

  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  .btn-secondary {
    background: transparent;
    color: #fff8e7;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }

  .btn-secondary:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  /* ===== STATS STYLES ===== */
  .stats-section {
    display: flex;
    justify-content: space-around;
    margin-top: 24px;
    background: rgba(255, 255, 255, 0.06);
    padding: 20px;
    border-radius: 20px;
    width: 100%;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .stat {
    text-align: center;
    position: relative;
    padding: 0 15px;
    flex: 1;
  }

  .stat::after {
    content: '';
    position: absolute;
    right: 0;
    top: 20%;
    height: 60%;
    width: 1px;
    background: rgba(255, 255, 255, 0.15);
  }

  .stat:last-child::after {
    display: none;
  }

  .stat-value {
    font-size: 2.2rem;
    font-weight: bold;
    margin-bottom: 5px;
    color: #fff8e7;
    text-shadow: 0 0 8px rgba(255, 248, 231, 0.3);
  }

  .stat-label {
    font-size: 0.9rem;
    opacity: 0.8;
    letter-spacing: 0.5px;
  }

  /* ===== CONTROL BAR ===== */
  .control-bar {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    gap: 10px;
    z-index: 100;
  }

  .icon-btn {
    background: transparent;
    border: none;
    padding: 10px;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.25s ease;
    -webkit-tap-highlight-color: transparent;
    color: #fff8e7;
  }

  .icon-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
  }

  .icon-btn.active {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
  }

  .icon-btn svg {
    transition: opacity 0.25s ease;
  }

  /* ===== FLOATING ELEMENTS ===== */
  .floating-elements {
    position: fixed;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 0;
    opacity: 0.7;
  }

  .floating-element {
    position: absolute;
    font-size: 24px;
    opacity: 0;
    animation: float 8s linear infinite;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
  }

  .floating-element:nth-child(3n) { animation-duration: 10s; }
  .floating-element:nth-child(3n+1) { animation-duration: 12s; }
  .floating-element:nth-child(3n+2) { animation-duration: 14s; }

  /* ===== ANIMATIONS ===== */
  @keyframes flip {
    0% { transform: rotateY(0); }
    50% { transform: rotateY(1800deg); }
    100% { transform: rotateY(1980deg); }
  }

  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  @keyframes float {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 0.8; }
    90% { opacity: 0.8; }
    100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
  }

  @keyframes celebrate {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  @keyframes spinGleam {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* === Confetti animation === */
  .confetti {
    position: fixed;
    width: 10px;
    height: 14px;
    opacity: 0.9;
    border-radius: 2px;
    z-index: 9999;
    animation: confettiFall 3s ease-out forwards;
  }
  @keyframes confettiFall {
    0% {
      transform: translateY(-10vh) translateX(0) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(110vh) translateX(var(--xShift)) rotate(720deg);
      opacity: 0;
    }
  }

  /* === Raindrops === */
  .raindrop {
    position: fixed;
    top: -20px;
    width: 2px;
    height: 18px;
    background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0));
    border-radius: 1px;
    opacity: 0.7;
    z-index: 950;
    animation: fall 1.2s linear infinite;
  }
  @keyframes fall {
    0% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(100vh); opacity: 0; }
  }
  
  /* === Game App Styles === */
  #game-app {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    display: none;
    background: linear-gradient(135deg, #1a2a6c, #6f5d7a, #25f37b);
    background-size: 400% 400%;
    animation: gradientShift 15s ease infinite;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  .game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    max-width: 1100px;
    margin: 0 auto;
  }

  /* Add a frosted container just for the title area */
.game-title-container {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 3px 15px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.game-title {
    font-size: 1.8rem;
    font-weight: 500;
    color: #fff8e7;
    text-shadow: 0 0 10px rgba(255, 248, 231, 0.3);
    margin: 0; /* Remove default margins */
}

  .game-content {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    width: 100%;
    max-width: 1100px;
    padding: 0 20px;
    margin: 0 auto;
    height: calc(100% - 80px);
  }

  .game-panel {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.12);
    color: #fff8e7;
  }

  .controls-panel {
    width: 240px;
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .board-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    flex: 1;
  }

  .board-container {
    position: relative;
    width: calc(var(--cell-size) * (var(--board-size) - 1));
    height: calc(var(--cell-size) * (var(--board-size) - 1));
    background-color: var(--board-color);
    margin: 0 auto;
    border-radius: 10px;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
    touch-action: none;
  }

  .grid-lines, 
  .intersections {
    position: absolute;
    top: 0; 
    left: 0;
    width: 100%; 
    height: 100%;
  }

  .grid-line { 
    position: absolute; 
    background-color: var(--grid-color); 
  }

  .grid-line.horizontal { 
    width: 100%; 
    height: 1px; 
  }

  .grid-line.vertical { 
    height: 100%; 
    width: 1px; 
  }

  .intersections {
    display: grid;
    grid-template-columns: repeat(var(--board-size), var(--cell-size));
    grid-template-rows: repeat(var(--board-size), var(--cell-size));
    margin-left: calc(var(--cell-size) / -2);
    margin-top: calc(var(--cell-size) / -2);
    touch-action: none;
  }

  .intersection {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.1s ease;
    touch-action: none;
  }

  .intersection:hover:not(.disabled) { 
    transform: scale(1.1); 
  }

  .intersection.disabled { 
    pointer-events: none; 
    opacity: 0.95; 
  }

  .stone {
    width: calc(var(--cell-size) * 0.82);
    height: calc(var(--cell-size) * 0.82);
    border-radius: 50%;
    z-index: 2;
    box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25), 0 2px 6px rgba(0,0,0,0.18);
    transition: box-shadow 0.3s ease;
  }

  .stone.black { 
    background: radial-gradient(circle at 30% 30%, #444, #000); 
  }

  .stone.white { 
    background: radial-gradient(circle at 30% 30%, #fff, #ccc); 
  }

  .stone.last-move {
    box-shadow: 
      inset 0 -6px 12px rgba(0,0,0,0.25), 
      0 2px 6px rgba(0,0,0,0.18),
      0 0 12px 6px rgba(255, 255, 0, 0.6);
    animation: pulse-glow 2s infinite alternate;
  }

  @keyframes pulse-glow {
    from { box-shadow: 
      inset 0 -6px 12px rgba(0,0,0,0.25), 
      0 2px 6px rgba(0,0,0,0.18),
      0 0 12px 6px rgba(255, 255, 0, 0.6); }
    to { box-shadow: 
      inset 0 -6px 12px rgba(0,0,0,0.25), 
      0 2px 6px rgba(0,0,0,0.18),
      0 0 16px 8px rgba(255, 255, 0, 0.8); }
  }

  .star-point {
    position: absolute;
    width: var(--star-point-size);
    height: var(--star-point-size);
    background: #566a88;
    border-radius: 50%;
    z-index: 1;
  }

  .game-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .form-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .form-label {
    font-size: 14px;
    font-weight: 500;
  }

  .form-input {
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.05);
    color: #fff8e7;
    font-size: 16px;
    outline: none;
    transition: all 0.2s ease;
  }

  .form-input:focus {
    border-color: rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.08);
  }

  .form-input::placeholder {
    color: rgba(255, 248, 231, 0.6);
  }

  .btn-group {
    display: flex;
    gap: 10px;
  }

  .btn-small {
    padding: 10px 16px;
    font-size: 14px;
    border-radius: 10px;
    flex: 1;
  }

  .game-status {
    margin-top: 15px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    font-size: 14px;
  }

  .status-item {
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
  }

  .status-item:last-child {
    margin-bottom: 0;
  }

  .status-label {
    opacity: 0.8;
  }

  .status-value {
    font-weight: 500;
  }

  /* Toast and undo notification styles */
  #toast {
    position: fixed;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%) translateY(8px);
    padding: 10px 14px;
    border-radius: 8px;
    background: rgba(255,255,255,0.08);
    backdrop-filter: blur(8px) saturate(120%);
    -webkit-backdrop-filter: blur(8px) saturate(120%);
    border: 1px solid rgba(255,255,255,0.12);
    color: #fff;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    opacity: 0;
    pointer-events: none;
    transition: opacity .36s ease, transform .36s ease;
    z-index: 9999;
  }
  
  #toast.show { 
    opacity: 1; 
    transform: translateX(-50%) translateY(0); 
    pointer-events: auto; 
  }
  
  .undo-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.12);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff8e7;
    z-index: 10000;
    text-align: center;
    max-width: 300px;
    width: 90%;
  }
  
  .undo-notification h3 {
    margin-bottom: 15px;
    font-size: 18px;
  }
  
  .undo-notification p {
    margin-bottom: 20px;
    font-size: 14px;
    line-height: 1.4;
  }
  
  .undo-notification-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
  }
  
  .undo-notification button {
    padding: 8px 16px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }
  
  .undo-notification .accept-btn {
    background: linear-gradient(90deg, #4CAF50, #45a049);
    color: white;
  }
  
  .undo-notification .decline-btn {
    background: linear-gradient(90deg, #f44336, #d32f2f);
    color: white;
  }
  
  /* Overlay for undo notification */
  .undo-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 9999;
  }

  /* Winning stones glow effect */
  .stone.winning-stone {
    box-shadow: 
      inset 0 -6px 12px rgba(0,0,0,0.25), 
      0 2px 6px rgba(0,0,0,0.18),
      0 0 12px 6px rgba(255, 255, 0, 0.8);
    animation: pulse-glow-win 1.5s infinite alternate;
  }

  @keyframes pulse-glow-win {
    from { 
      box-shadow: 
        inset 0 -6px 12px rgba(0,0,0,0.25), 
        0 2px 6px rgba(0,0,0,0.18),
        0 0 12px 6px rgba(255, 255, 0, 0.8); 
    }
    to { 
      box-shadow: 
        inset 0 -6px 12px rgba(0,0,0,0.25), 
        0 2px 6px rgba(0,0,0,0.18),
        0 0 20px 10px rgba(255, 255, 0, 1); 
    }
  }
  
  /* ===== RESPONSIVE STYLES ===== */
  @media (max-width: 768px) {
    .card {
      padding: 24px 16px;
      max-width: 90%;
    }
    
    .title {
      font-size: 1.8rem;
    }
    
    .coin-container {
      width: 140px;
      height: 140px;
    }
    
    .result-text {
      font-size: 1.2rem;
      padding: 12px 20px;
    }
    
    .btn {
      padding: 12px 30px;
      font-size: 1rem;
    }
    
    .stats-section {
      padding: 16px;
    }
    
    .stat-value {
      font-size: 1.8rem;
    }
    
    .game-content {
      flex-direction: column;
      align-items: center;
      padding: 0 10px;
    }
    
    .controls-panel {
      width: 100%;
      max-width: 400px;
    }
    
    .board-panel {
      width: 100%;
      padding: 10px 0;
    }
    
    .game-panel {
      padding: 15px;
    }
  }

  @media (max-width: 480px) {
    .card {
      padding: 20px 12px;
    }
    
    .title {
      font-size: 1.6rem;
    }
    
    .subtitle {
      font-size: 0.9rem;
    }
    
    .coin-container {
      width: 120px;
      height: 120px;
    }
    
    .result-text {
      font-size: 1.1rem;
    }
    
    .btn {
      padding: 10px 24px;
      font-size: 0.9rem;
    }
    
    .stats-section {
      padding: 12px;
    }
    
    .stat {
      padding: 0 10px;
    }
    
    .stat-value {
      font-size: 1.6rem;
    }
    
    .control-bar {
      top: 10px;
      right: 10px;
    }
  }
</style>
</head>

<body>
<div id="dim-overlay"></div>
<canvas id="splash-particles"></canvas>

<div class="main-container">
  <!-- Floating Elements -->
  <div class="floating-elements" id="floating-elements"></div>
  
  <!-- Control Bar -->
  <div class="control-bar">
    <button class="icon-btn" id="game-btn" aria-label="Play Gomoku game">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <line x1="3" y1="9" x2="21" y2="9"></line>
        <line x1="9" y1="21" x2="9" y2="9"></line>
      </svg>
    </button>
    
    <button class="icon-btn" id="effect-btn" aria-label="Toggle visual effects">
      <svg id="effect-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
           fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
           width="22" height="22" style="display:block;">
        <path d="M17.5 19a4.5 4.5 0 0 0 0-9 5.5 5.5 0 0 0-10.9 1A4 4 0 0 0 7 19h10.5z"/>
      </svg>
      <svg id="effect-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
           fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"
           width="22" height="22" style="display:none;">
        <path d="M17.5 19a4.5 4.5 0 0 0 0-9 5.5 5.5 0 0 0-10.9 1A4 4 0 0 0 7 19h10.5z"/>
      </svg>
    </button>
    
    <button class="icon-btn" id="mute-btn" aria-label="Toggle sound">
      <svg id="mute-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" style="display:none;">
        <path d="M11 5L6 9H2V15H6L11 19V5Z" />
        <line x1="23" y1="9" x2="17" y2="15" />
        <line x1="17" y1="9" x2="23" y2="15" />
      </svg>
      <svg id="unmute-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" style="display:block;">
        <path d="M11 5L6 9H2V15H6L11 19V5Z" />
        <path d="M15.54 8.46C16.4774 9.39764 17.004 10.6692 17.004 12C17.004 13.3308 16.4774 14.6024 15.54 15.54" />
        <path d="M19.07 4.93C20.9447 6.80528 21.9979 9.34836 21.9979 12C21.9979 14.6516 20.9447 17.1947 19.07 19.07" />
      </svg>
    </button>
  </div>
  
  <!-- Main Card -->
  <div class="card">
    <div class="header">
      <h1 class="title">Ê¨¢ËøéÂ∞èÂÆùÂÆùÔºÅ</h1>
      <p class="subtitle">
        ËøôÂè™ÊòØ‰∏Ä‰ª∂Âπ≥Â∏∏ÁöÑÂ∞è‰∫ãÔºåÂπ∂‰∏ç‰ºöÂÜ≥ÂÆö‰Ω†ÁöÑËøêÊ∞îÂÆùÂÆù„ÄÇ‰ΩÜÂ¶ÇÊûúÂÆÉËÉΩÁªô‰Ω†‰∏ÄÁÇπÁÇπÊøÄÂä±ÔºåÈÇ£Â∞±ÊòØÊàëÊúÄÂ§ßÁöÑÂøÉÊÑø„ÄÇ
        ‰∏çÁÆ°ÊÄéÊ†∑Ôºå‰Ω†Ê∞∏ËøúÊòØÊúÄÊ£íÁöÑÈÉ≠ÂΩ§ÂΩ§„ÄÇÊàëÁà±‰Ω†„ÄÇ
      </p>
    </div>
    
    <div class="coin-section">
      <div class="coin-container">
        <div class="coin" id="coin">
          <div class="coin-face coin-front">
            <div class="coin-image-container">
              <img src="A.png" class="coin-image" alt="A Side" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
              <div class="coin-fallback" style="display:none;">A</div>
            </div>
          </div>
          <div class="coin-face coin-back">
            <div class="coin-image-container">
              <img src="B.png" class="coin-image" alt="B Side" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
              <div class="coin-fallback" style="display:none;">B</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="result-section">
        <div class="result-text" id="result">ÂÆùÂÆùÂºÄÂßãÂêßÔºÅ</div>
      </div>
      
      <button class="btn" id="flip-button">
        ÁøªËΩ¨Á°¨Â∏Å
      </button>
    </div>
    
    <div class="stats-section">
      <div class="stat">
        <div class="stat-value" id="a-count">0</div>
        <div class="stat-label">AÈù¢Ê¨°Êï∞</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="total-count">0</div>
        <div class="stat-label">ÊÄªÊ¨°Êï∞</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="b-count">0</div>
        <div class="stat-label">BÈù¢Ê¨°Êï∞</div>
      </div>
    </div>
  </div>
</div>

<!-- Game App (Hidden by default) -->
<div id="game-app">
  <div class="floating-elements" id="game-floating-elements"></div>
  
  <div class="game-header">
    <div class="game-title-container">
        <h1 class="game-title">Â∞èÂÆùÂÆùÁöÑ‰∫îÂ≠êÊ£ã</h1>
    </div>
    <button class="btn btn-secondary" id="back-btn">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="19" y1="12" x2="5" y2="12"></line>
        <polyline points="12 19 5 12 12 5"></polyline>
      </svg>
      ËøîÂõû
    </button>
  </div>
  
  <div class="game-content">
    <div class="game-panel controls-panel">
      <div class="game-controls">
        <div class="form-group">
          <label class="form-label" for="roomId">ÊàøÈó¥‰ª£Á†Å</label>
          <input class="form-input" id="roomId" placeholder="ÂàõÂª∫ÊàñÁ≤òË¥¥ÊàøÈó¥‰ª£Á†Å" type="text" autocomplete="off" inputmode="text" />
        </div>
        
        <div class="btn-group" id="initialButtons">
          <button class="btn btn-small" id="createBtn">ÂàõÂª∫ÊàøÈó¥</button>
          <button class="btn btn-small btn-secondary" id="joinBtn">Âä†ÂÖ•ÊàøÈó¥</button>
        </div>
        
        <div class="btn-group" id="inRoomButtons" style="display:none">
          <button class="btn btn-small btn-secondary" id="resetBtn">ÈáçÁΩÆÊ£ãÁõò</button>
          <button class="btn btn-small btn-secondary" id="leaveBtn">Á¶ªÂºÄÊàøÈó¥</button>
          <button class="btn btn-small" id="undoBtn" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M3 7v6h6"/>
              <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
            </svg>
            Êí§ÈîÄ
          </button>
        </div>
        
        <div class="game-status">
          <div class="status-item">
            <span class="status-label">Áä∂ÊÄÅ:</span>
            <span class="status-value" id="status">Êú™ËøûÊé•</span>
          </div>
          <div class="status-item">
            <span class="status-label">Áé©ÂÆ∂:</span>
            <span class="status-value" id="players">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">ÂõûÂêà:</span>
            <span class="status-value" id="turnIndicator">‚Äî</span>
          </div>
          <div class="status-item">
            <span class="status-label">‰Ω†ÁöÑËßíËâ≤:</span>
            <span class="status-value" id="youIndicator">‚Äî</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="game-panel board-panel">
      <div class="board-container" id="boardContainer">
        <div class="grid-lines" id="gridLines"></div>
        <div class="intersections" id="board"></div>
      </div>
    </div>
  </div>
  
  <!-- Toast -->
  <div id="toast" role="status" aria-live="polite"></div>
  
  <!-- Undo notification (hidden by default) -->
  <div id="undoNotification" class="undo-notification" style="display: none;">
    <h3>Êí§ÈîÄËØ∑Ê±Ç</h3>
    <p id="undoRequestMessage">ÂØπÊñπËØ∑Ê±ÇÊí§ÈîÄ‰∏ä‰∏ÄÊ≠•Ê£ã„ÄÇÊòØÂê¶ÂêåÊÑèÔºü</p>
    <div class="undo-notification-buttons">
      <button id="acceptUndo" class="accept-btn">ÂêåÊÑè</button>
      <button id="declineUndo" class="decline-btn">ÊãíÁªù</button>
    </div>
  </div>
  <div id="undoOverlay" class="undo-overlay" style="display: none;"></div>
</div>

<!-- Audio elements -->
<audio id="flip-sound" preload="auto">
  <source src="coin-flip-shimmer-85750.mp3" type="audio/mpeg">
</audio>

<audio id="bgm" loop preload="auto">
  <source src="S.mp3" type="audio/mpeg">
</audio>

<audio id="stone-sound" preload="auto">
  <source src="tap.mp3" type="audio/mpeg">
</audio>

<script>
// Your original JavaScript code goes here with minimal changes
document.addEventListener('DOMContentLoaded', function() {
  const coin = document.getElementById('coin');
  const flipButton = document.getElementById('flip-button');
  const result = document.getElementById('result');
  const aCount = document.getElementById('a-count');
  const bCount = document.getElementById('b-count');
  const totalCount = document.getElementById('total-count');
  const floatingElements = document.getElementById('floating-elements');
  const flipSound = document.getElementById('flip-sound');
  const stoneSound = document.getElementById('stone-sound');
  const muteBtn = document.getElementById('mute-btn');
  const muteIcon = document.getElementById('mute-icon');
  const unmuteIcon = document.getElementById('unmute-icon');
  const bgm = document.getElementById('bgm');
  const dimOverlay = document.getElementById('dim-overlay');

  const effectBtn = document.getElementById('effect-btn');
  const effectOn = document.getElementById('effect-on');
  const effectOff = document.getElementById('effect-off');

  // Game app elements
  const gameApp = document.getElementById('game-app');
  const gameBtn = document.getElementById('game-btn');
  const backBtn = document.getElementById('back-btn');
  const undoBtn = document.getElementById('undoBtn');
  const undoNotification = document.getElementById('undoNotification');
  const undoOverlay = document.getElementById('undoOverlay');
  const acceptUndo = document.getElementById('acceptUndo');
  const declineUndo = document.getElementById('declineUndo');
  const undoRequestMessage = document.getElementById('undoRequestMessage');

  let effectsEnabled = true; // start OFF every time
  let isMuted = true;
  flipSound.muted = true;
  stoneSound.muted = true;
  bgm.muted = true;
  muteIcon.style.display = 'block';
  unmuteIcon.style.display = 'none';
  effectOn.style.display = 'block';
  effectOff.style.display = 'none';
  effectBtn.classList.toggle('active', effectsEnabled);

  // --- GAME APP TOGGLE ---
  gameBtn.addEventListener('click', () => {
    gameApp.style.display = 'block';
    // Initialize the game if not already done
    if (typeof initGame === 'function') {
      initGame();
    }
    // Refit board after showing app
    setTimeout(fitBoardToViewport, 100);
  });

  backBtn.addEventListener('click', () => {
    gameApp.style.display = 'none';
  });

  // --- EFFECT TOGGLE ---
  function toggleEffects() {
    effectsEnabled = !effectsEnabled;
    effectOn.style.display = effectsEnabled ? 'block' : 'none';
    effectOff.style.display = effectsEnabled ? 'none' : 'block';
    effectBtn.classList.toggle('active', effectsEnabled);
  }

  effectBtn.addEventListener('click', toggleEffects);

  // --- BGM AUTOPLAY ---
  function tryPlayBgm() {
    bgm.volume = 0.07;
    bgm.play().catch(() => {
      const resume = () => {
        bgm.play().catch(()=>{});
        document.removeEventListener('touchstart', resume);
        document.removeEventListener('click', resume);
      };
      document.addEventListener('touchstart', resume, { once: true });
      document.addEventListener('click', resume, { once: true });
    });
  }
  tryPlayBgm();

  // --- MUTE BUTTON ---
  function toggleMute() {
    isMuted = !isMuted;
    muteIcon.style.display = isMuted ? 'block' : 'none';
    unmuteIcon.style.display = isMuted ? 'none' : 'block';
    muteBtn.classList.toggle('active', !isMuted);
    flipSound.muted = isMuted;
    stoneSound.muted = isMuted;
    bgm.muted = isMuted;
  }

  muteBtn.addEventListener('click', toggleMute);

  // --- CONFETTI ---
  function createConfetti() {
    for (let i = 0; i < 120; i++) {
      const confetti = document.createElement('div');
      confetti.classList.add('confetti');
      confetti.style.left = Math.random() * 100 + 'vw';
      confetti.style.top = '-10vh';
      confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 80%, 60%)`;
      confetti.style.setProperty('--xShift', (Math.random() * 200 - 100) + 'px');
      confetti.style.animationDelay = (Math.random() * 0.8) + 's';
      confetti.style.animationDuration = (2.5 + Math.random() * 1.5) + 's';
      document.body.appendChild(confetti);
      setTimeout(() => confetti.remove(), 2500);
    }
  }

  // --- RAIN ---
  const thunderAudio = new Audio('thunder-soft.mp3');
  thunderAudio.volume = 0.3;
  function createRainScene() {
    document.body.classList.add('raining');
    dimOverlay.style.opacity = '1';
    const rainContainer = document.createElement('div');
    rainContainer.classList.add('rain-container');
    document.body.appendChild(rainContainer);

    for (let i = 0; i < 70; i++) {
      const drop = document.createElement('div');
      drop.classList.add('raindrop');
      drop.style.left = Math.random() * 100 + 'vw';
      drop.style.animationDuration = (0.7 + Math.random() * 0.6) + 's';
      drop.style.animationDelay = Math.random() + 's';
      rainContainer.appendChild(drop);
    }

    if (!isMuted) {
      thunderAudio.currentTime = 0;
      thunderAudio.play().catch(()=>{});
    }

    setTimeout(() => {
      dimOverlay.style.opacity = '0';
      setTimeout(() => {
        document.body.classList.remove('raining');
        rainContainer.remove();
      }, 400);
    }, 2500);
  }

  // --- COIN FLIP ---
  let isFlipping = false, aCounter = 0, bCounter = 0, totalFlips = 0;
  
  function createFloatingElements() {
    const containers = [
        document.getElementById('floating-elements'),
        document.getElementById('game-floating-elements')
    ];
    
    const cuteEmojis = ['‚ù§Ô∏è','‚ú®','üåü','ü•∞','üòä','üå∏','üí´','üéÄ','üíñ','ü¶ã','üê∞','üê±','üê∂','üåà','üéà','üéµ','üíï','üíù','üíò','üíì','üíó','üíû','üíü','‚ù£Ô∏è','‚≠ê','üå∫','üå∑','üíê','üåº','ü¶Ñ','üçÄ','üéÇ','üç¨','üç≠','üéÅ','üéÄ','üëë','üíé','üîÆ','üéµ'];

    containers.forEach(container => {
        if (!container) return;
        container.innerHTML = '';
        
        for(let i = 0; i < 25; i++) {
            const element = document.createElement('div');
            element.className = 'floating-element';
            element.innerHTML = cuteEmojis[Math.floor(Math.random() * cuteEmojis.length)];
            element.style.left = Math.random() * 100 + 'vw';
            element.style.animationDelay = Math.random() * 8 + 's';
            element.style.fontSize = (Math.random() * 20 + 15) + 'px';
            element.style.animation = `float ${8 + Math.random() * 6}s linear infinite`;
            container.appendChild(element);
        }
    });
  }
  createFloatingElements();

  const canvas = document.getElementById('splash-particles');
  const ctx = canvas.getContext('2d');
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  let particles = Array.from({ length:120 }, () => ({
    x: Math.random() * innerWidth,
    y: Math.random() * innerHeight,
    r: Math.random() * 2 + 1,
    dx: (Math.random() - 0.5) * 0.3,
    dy: (Math.random() - 0.5) * 0.3,
  }));

  function drawParticles() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(236, 191, 255,0.7)';
    for (let p of particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      p.x += p.dx; p.y += p.dy;
      if (p.x < 0 || p.x > canvas.width) p.dx *= -1;
      if (p.y < 0 || p.y > canvas.height) p.dy *= -1;
    }
    requestAnimationFrame(drawParticles);
  }
  drawParticles();

  flipButton.addEventListener('touchstart', function(e) {
  if (isFlipping) return;
  
  // Prevent any default zoom/scroll on tap (safe in PWA)
  e.preventDefault();
  
  // Trigger the flip logic (same as your original click handler)
  isFlipping = true;
  flipButton.disabled = true;
  result.textContent = "ÁøªËΩ¨‰∏≠...";

  if (!isMuted) {
    playSoundImmediately(flipSound);
  }

  const isA = Math.random() < 0.5;
  const fullSpins = 5;
  const finalAngle = isA ? 0 : 180;
  const totalRotation = 360 * fullSpins + finalAngle;
  coin.style.transition = 'transform 2s cubic-bezier(0.25, 1, 0.5, 1)';
  coin.style.transform = `rotateY(${totalRotation}deg)`;

  setTimeout(() => {
    coin.style.transition = 'none';
    coin.style.transform = `rotateY(${finalAngle}deg)`;
    if (isA) {
      result.innerHTML = "ÊòØ <strong>A</strong>ÔºÅ";
      aCounter++; aCount.textContent = aCounter;
      if (effectsEnabled) createConfetti();
    } else {
      result.innerHTML = "ÊòØ <strong>ÂÇªB :(</strong>";
      bCounter++; bCount.textContent = bCounter;
      if (effectsEnabled) createRainScene();
    }
    result.classList.add('celebrate');
    setTimeout(() => result.classList.remove('celebrate'), 500);
    totalFlips++; totalCount.textContent = totalFlips;

    if (!effectsEnabled) {
      isFlipping = false;
      flipButton.disabled = false;
    } else {
      setTimeout(() => {
        isFlipping = false;
        flipButton.disabled = false;
      }, 3000);
    }
  }, 2000);
}, { passive: false });

  flipButton.addEventListener('click', function() {
    if (isFlipping) return;
    isFlipping = true;
    flipButton.disabled = true;
    result.textContent = "ÁøªËΩ¨‰∏≠...";

    if (!isMuted) {
      // Play coin flip sound immediately with no delay
      playSoundImmediately(flipSound);
    }

    const isA = Math.random() < 0.5;
    const fullSpins = 5;
    const finalAngle = isA ? 0 : 180;
    const totalRotation = 360 * fullSpins + finalAngle;
    coin.style.transition = 'transform 2s cubic-bezier(0.25, 1, 0.5, 1)';
    coin.style.transform = `rotateY(${totalRotation}deg)`;

    setTimeout(() => {
  coin.style.transition = 'none';
  coin.style.transform = `rotateY(${finalAngle}deg)`;
  if (isA) {
    result.innerHTML = "ÊòØ <strong>A</strong>ÔºÅ";
    aCounter++; aCount.textContent = aCounter;
    if (effectsEnabled) createConfetti();
  } else {
    result.innerHTML = "ÊòØ <strong>ÂÇªB :(</strong>";
    bCounter++; bCount.textContent = bCounter;
    if (effectsEnabled) createRainScene();
  }
  result.classList.add('celebrate');
  setTimeout(() => result.classList.remove('celebrate'), 500);
  totalFlips++; totalCount.textContent = totalFlips;

  // Enable button immediately if effects are disabled
  if (!effectsEnabled) {
    isFlipping = false;
    flipButton.disabled = false;
  }
  // If effects are enabled, wait for animation to end
  else {
    setTimeout(() => {
      isFlipping = false;
      flipButton.disabled = false;
    }, 3000); // Wait longer for effects to finish
  }
}, 2000);
  });
});

// Function to play sound immediately with no delay
function playSoundImmediately(sound) {
  // Stop and reset the sound
  sound.pause();
  sound.currentTime = 0;
  
  // Create a promise to play the sound
  const playPromise = sound.play();
  
  // If the promise fails, try to handle it
  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.log("Audio play failed:", error);
      // Try again with a small delay
      setTimeout(() => {
        sound.currentTime = 0;
        sound.play().catch(e => console.log("Second attempt failed:", e));
      }, 100);
    });
  }
}

// Game initialization function
function initGame() {
  // Set CSS variables for the game
  document.documentElement.style.setProperty('--board-size', '15');
  document.documentElement.style.setProperty('--grid-color', 'rgba(67, 133, 224, 0.4)');
  document.documentElement.style.setProperty('--board-color', 'rgba(255, 255, 255, 0.7)');
  document.documentElement.style.setProperty('--star-point-size', '4px');
  document.documentElement.style.setProperty('--panel-pad', '10px');
  document.documentElement.style.setProperty('--control-w', '220px');
  
  // Initialize the game here
  // This would contain the entire Gomoku game code from your original file
  // For brevity, I'm not including the full Firebase integration here
  // but it would be placed in this function
  console.log("Game initialized");
}
</script>

<!-- Firebase and Gomoku game script would go here -->

<script type="module">
// Firebase imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getDatabase, ref, set, onValue, update, get, push, runTransaction, onDisconnect, off, remove } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

/* ---------- Firebase config (unchanged) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyCUkxMlN4UH7viDG65qUwHlpJPyX4HrG_k",
  authDomain: "gomoku-f5642.firebaseapp.com",
  databaseURL: "https://gomoku-f5642-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "gomoku-f5642",
  storageBucket: "gomoku-f5642.firebasestorage.app",
  messagingSenderId: "565669580117",
  appId: "1:565669580117:web:6ffc82f164aa55bf0f73dc",
  measurementId: "G-1KXD1TVC8S"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

/* ---------- UI refs ---------- */
const boardEl = document.getElementById("board");
const gridLinesEl = document.getElementById("gridLines");
const statusEl = document.getElementById("status");
const playersEl = document.getElementById("players");
const turnEl = document.getElementById("turnIndicator");
const youEl = document.getElementById("youIndicator");
const roomInput = document.getElementById("roomId");
const createBtn = document.getElementById("createBtn");
const joinBtn = document.getElementById("joinBtn");
const resetBtn = document.getElementById("resetBtn");
const leaveBtn = document.getElementById("leaveBtn");
const undoBtn = document.getElementById("undoBtn");
const undoNotification = document.getElementById("undoNotification");
const undoOverlay = document.getElementById("undoOverlay");
const acceptUndo = document.getElementById("acceptUndo");
const declineUndo = document.getElementById("declineUndo");
const undoRequestMessage = document.getElementById("undoRequestMessage");
const toast = document.getElementById("toast");
const initialButtons = document.getElementById("initialButtons");
const inRoomButtons = document.getElementById("inRoomButtons");
const boardContainer = document.getElementById("boardContainer");

const SIZE = 15;

/* ---------- state ---------- */
let localUID = null, roomId = null, unsubscribeRoom = null;
let role = null, board = Array(SIZE).fill(null).map(()=>Array(SIZE).fill(null));
let turn = "black", status = "idle";
let roomOwner = null;
let lastMoveId = null; // Track the last move for undo functionality
let undoRequested = false; // Track if an undo request is active
let lastProcessedMoveId = null; // Track the last move we've processed for sound
let autoResetTimer = null; // Timer for automatic reset
let winningStones = []; // Track the winning stones

/* ---------- Authentication ---------- */
signInAnonymously(auth).catch(console.error);
onAuthStateChanged(auth, user => {
  if (user) { localUID = user.uid; statusEl.textContent = "ÂÆùÂÆùÊàëÁà±‰Ω†"; }
  else { localUID = null; statusEl.textContent = "Not connected"; }
});

/* ---------- Toast helper ---------- */
let toastTimer = null;
function showToast(msg, time=2200){
  if(toastTimer) clearTimeout(toastTimer);
  toast.textContent = msg;
  toast.classList.add("show");
  toastTimer = setTimeout(()=> toast.classList.remove("show"), time);
}

/* ---------- Responsive cell size calculation ---------- */
function fitBoardToViewport(){
  const headerEl = document.querySelector('.game-header');
  const headerHeight = headerEl ? headerEl.offsetHeight : 80;
  const contentPadding = window.innerWidth <= 768 ? 20 : 40; // Adjusted for mobile
  const footerPadding = 40;
  const availableW = Math.max(120, window.innerWidth - contentPadding);
  const availableH = Math.max(120, window.innerHeight - headerHeight - footerPadding);
  let avail = Math.min(availableW, availableH);

  if (window.innerWidth > 900) {
    const controlsPanel = document.querySelector('.controls-panel');
    if (controlsPanel) {
      const controlsW = controlsPanel.offsetWidth + 40; // gap + padding
      avail = Math.min(avail, window.innerWidth - controlsW - contentPadding);
    }
  }

  const cell = Math.floor(avail / (SIZE ));
  const finalCell = Math.max(16, Math.min(36, cell)); // Adjusted range for better mobile scaling
  document.documentElement.style.setProperty('--cell-size', finalCell + 'px');

  // Adjust star point size proportionally
  const starSize = Math.max(3, Math.floor(finalCell * 0.15));
  document.documentElement.style.setProperty('--star-point-size', starSize + 'px');
}
window.addEventListener('resize', fitBoardToViewport);
window.addEventListener('orientationchange', fitBoardToViewport);
setTimeout(fitBoardToViewport, 50);

/* ---------- Render board ---------- */
function renderBoard() {
  gridLinesEl.innerHTML = "";
  for(let i=0;i<SIZE-1;i++){
    const h=document.createElement("div");
    h.className="grid-line horizontal"; h.style.top=`calc(${i} * var(--cell-size))`;
    gridLinesEl.appendChild(h);
    const v=document.createElement("div");
    v.className="grid-line vertical"; v.style.left=`calc(${i} * var(--cell-size))`;
    gridLinesEl.appendChild(v);
  }

  boardEl.innerHTML = "";
  const stars=[[3,3],[3,11],[7,7],[11,3],[11,11]];
  for(let r=0;r<SIZE;r++){
  for(let c=0;c<SIZE;c++){
    const intersection=document.createElement("div");
    intersection.className="intersection"; intersection.dataset.r=r; intersection.dataset.c=c;
    if(stars.some(([rr,cc])=>rr===r&&cc===c)){
      const sp=document.createElement("div"); sp.className="star-point"; intersection.appendChild(sp);
    }
    const val=board[r][c];
    if(val){
      const s=document.createElement("div"); 
      s.className="stone " + val;
      
      // Add last-move class to the most recent stone
      if (lastMoveId && r === lastMoveId.r && c === lastMoveId.c) {
        s.classList.add("last-move");
      }
      
      // Add winning-stone class to all winning stones
      if (winningStones.some(stone => stone.r === r && stone.c === c)) {
        s.classList.add("winning-stone");
      }
      
      intersection.appendChild(s);
      intersection.classList.add("disabled");
    }
    
    // Add touchstart + click listeners here for better iOS responsiveness
    const handleCellTap = function(e) {
      e.preventDefault();
      onCellClick(e);
    };
    intersection.addEventListener('touchstart', handleCellTap, { passive: false });
    intersection.addEventListener("click", onCellClick);
    
    boardEl.appendChild(intersection);
  }
}
  turnEl.textContent="Turn: "+(turn||"‚Äî");
  youEl.textContent="You: "+(role||"‚Äî");
  
  // Update undo button state
  updateUndoButton();
  
  // Update reset button state - disable if game is over
  updateResetButton();
}

/* ---------- Update reset button state ---------- */
function updateResetButton() {
  // Enable reset button only if:
  // 1. We're in a room
  // 2. We're a player (black or white)
  // 3. Game is still playing (not ended)
  const isPlayer = role === "black" || role === "white";
  const isGameOver = status && status.endsWith("-won");
  const canReset = roomId && isPlayer && !isGameOver;
  
  resetBtn.disabled = !canReset;
  
  // Visual feedback for disabled state
  if (resetBtn.disabled) {
    resetBtn.style.opacity = "0.5";
    resetBtn.style.cursor = "not-allowed";
  } else {
    resetBtn.style.opacity = "1";
    resetBtn.style.cursor = "pointer";
  }
}

/* ---------- Update undo button state ---------- */
function updateUndoButton() {
  // Enable undo button only if:
  // 1. We're in a room and playing
  // 2. It's not our turn (we just made a move)
  // 3. There are moves to undo
  // 4. No undo request is currently active
  const movesExist = lastMoveId !== null;
  const isOurTurn = role === turn;
  const isGameOver = status && status.endsWith("-won");
  const canUndo = roomId && !isGameOver && status === "playing" && !isOurTurn && movesExist && !undoRequested;
  
  undoBtn.disabled = !canUndo;
}

/* ---------- Cell click handler ---------- */
function onCellClick(e){
  const r = +e.currentTarget.dataset.r, c = +e.currentTarget.dataset.c;
  if(status !== "playing"){ 
    if(status && status.endsWith("-won")) showToast("Game over ‚Äî reset to play again");
    else showToast("ËØ∑ÂÖàÂä†ÂÖ•ÊàñÂàõÂª∫ÊàøÈó¥"); 
    return; 
  }
  if(role !== turn){ showToast("ËøòÊ≤°ËΩÆÂà∞ÂÆùÂÆùÂë¢"); return; }
  if(board[r][c]) return;
  
  // Play stone placement sound immediately
  const stoneSound = document.getElementById('stone-sound');
  if (!stoneSound.muted) {
    playSoundImmediately(stoneSound);
  }
  
  const path = `rooms/${roomId}/moves`;
  const moveRef = push(ref(db, path));
  const moveId = moveRef.key;
  set(moveRef, { r, c, color: role, by: localUID, ts: Date.now() });
  
  // Store the last move ID for potential undo
  lastMoveId = { r, c, id: moveId };
  
  // Update undo button state
  updateUndoButton();
}

/* ---------- Undo functionality ---------- */
undoBtn.addEventListener("click", async () => {
  if (undoBtn.disabled) return;
  
  // Disable undo button to prevent multiple requests
  undoBtn.disabled = true;
  undoRequested = true;
  
  // Send undo request to Firebase
  const undoRequestRef = push(ref(db, `rooms/${roomId}/undoRequests`));
  await set(undoRequestRef, {
    from: localUID,
    moveId: lastMoveId.id,
    ts: Date.now()
  });
  
  showToast("Êí§ÈîÄËØ∑Ê±ÇÂ∑≤ÂèëÈÄÅÔºåÁ≠âÂæÖÂØπÊñπÁ°ÆËÆ§...");
});

// Handle undo request notifications
function setupUndoListener() {
  if (!roomId) return;
  
  const undoRequestsRef = ref(db, `rooms/${roomId}/undoRequests`);
  onValue(undoRequestsRef, (snapshot) => {
    const requests = snapshot.val();
    if (!requests) return;
    
    // Get the most recent request
    const requestKeys = Object.keys(requests);
    const latestKey = requestKeys[requestKeys.length - 1];
    const request = requests[latestKey];
    
    // If the request is for us (we're the opponent) and we haven't responded yet
    if (request && request.from !== localUID && role === turn && !request.responded) {
      // Show undo notification
      undoRequestMessage.textContent = `ÂØπÊñπËØ∑Ê±ÇÊí§ÈîÄ‰∏ä‰∏ÄÊ≠•Ê£ã„ÄÇÊòØÂê¶ÂêåÊÑèÔºü`;
      undoNotification.style.display = "block";
      undoOverlay.style.display = "block";
      
      // Set up accept/decline handlers
      const handleResponse = async (accepted) => {
        // Update the request with our response
        await update(ref(db, `rooms/${roomId}/undoRequests/${latestKey}`), {
          responded: true,
          accepted: accepted,
          respondedBy: localUID,
          responseTs: Date.now()
        });
        
        // Hide notification
        undoNotification.style.display = "none";
        undoOverlay.style.display = "none";
        
        if (accepted) {
          // Remove the last move
          await remove(ref(db, `rooms/${roomId}/moves/${request.moveId}`));
          showToast("Â∑≤ÂêåÊÑèÊí§ÈîÄËØ∑Ê±Ç");
        } else {
          showToast("Â∑≤ÊãíÁªùÊí§ÈîÄËØ∑Ê±Ç");
        }
        
        // Clean up event listeners
        acceptUndo.removeEventListener("click", acceptHandler);
        declineUndo.removeEventListener("click", declineHandler);
      };
      
      const acceptHandler = () => handleResponse(true);
      const declineHandler = () => handleResponse(false);
      
      acceptUndo.addEventListener("click", acceptHandler);
      declineUndo.addEventListener("click", declineHandler);
    }
  });
}

// Listen for undo request responses
function setupUndoResponseListener() {
  if (!roomId) return;
  
  const undoRequestsRef = ref(db, `rooms/${roomId}/undoRequests`);
  onValue(undoRequestsRef, (snapshot) => {
    const requests = snapshot.val();
    if (!requests) {
      undoRequested = false;
      updateUndoButton();
      return;
    }
    
    // Check if our request was responded to
    const requestKeys = Object.keys(requests);
    for (const key of requestKeys) {
      const request = requests[key];
      if (request.from === localUID && request.responded) {
        // Our request was responded to
        undoRequested = false;
        updateUndoButton();
        
        if (request.accepted) {
          showToast("ÂØπÊñπÂ∑≤ÂêåÊÑèÊí§ÈîÄËØ∑Ê±Ç");
        } else {
          showToast("ÂØπÊñπÊãíÁªù‰∫ÜÊí§ÈîÄËØ∑Ê±Ç");
        }
        
        // Remove the request from Firebase
        remove(ref(db, `rooms/${roomId}/undoRequests/${key}`));
        break;
      }
    }
  });
}

/* ---------- Room cleanup function ---------- */
async function checkAndCleanupRoom(roomIdToCheck) {
  try {
    const roomRef = ref(db, `rooms/${roomIdToCheck}`);
    const roomSnap = await get(roomRef);
    
    if (!roomSnap.exists()) return;
    
    const roomData = roomSnap.val();
    const players = roomData.players || {};
    
    // Check if both player slots are empty or null
    const blackEmpty = !players.black || players.black === '';
    const whiteEmpty = !players.white || players.white === '';
    
    if (blackEmpty && whiteEmpty) {
      // Room is empty - delete it
      console.log(`Deleting empty room: ${roomIdToCheck}`);
      await remove(roomRef);
      showToast("Room deleted (no players)");
    }
  } catch (error) {
    console.error("Error checking room cleanup:", error);
  }
}

/* ---------- Update local role based on player assignments ---------- */
function updateLocalRole(players) {
  if (!players || !localUID) return;
  
  if (players.black === localUID) {
    role = "black";
  } else if (players.white === localUID) {
    role = "white";
  } else {
    role = "spectator";
  }
  
  console.log("Updated local role to:", role);
  youEl.textContent = "You: " + role;
}

/* ---------- Automatic reset function ---------- */
async function scheduleAutoReset() {
  // Clear any existing timer
  if (autoResetTimer) {
    clearTimeout(autoResetTimer);
  }

  // Set new timer for 3 seconds
  autoResetTimer = setTimeout(async () => {
    if (!roomId) {
      console.log("No room ID, cannot reset");
      return;
    }

    const roomRef = ref(db, `rooms/${roomId}`);

    await runTransaction(roomRef, (roomData) => {
      if (!roomData) return;

      const currentStatus = roomData.status;
      if (!currentStatus || !currentStatus.endsWith("-won")) {
        // Not in won state, abort reset
        return;
      }

      const winnerColor = currentStatus.split('-')[0];  // "white" or "black"

      const players = roomData.players || {};

      console.log("Current players before reset:", players);
      console.log("Last winner:", winnerColor);

      let newBlackPlayer, newWhitePlayer;

      if (winnerColor === "black") {
        // Black won - black stays black, white stays white
        newBlackPlayer = players.black;
        newWhitePlayer = players.white;
        console.log("Black won - keeping same roles");
      } else {
        // White won - swap roles: winner becomes black, loser (black) becomes white
        newBlackPlayer = players.white;  // Winner becomes black
        newWhitePlayer = players.black;  // Loser becomes white
        console.log("White won - swapping roles: winner becomes black");
      }

      console.log("New assignments - Black:", newBlackPlayer, "White:", newWhitePlayer);

      // Reset the room with new player assignments
      roomData.createdAt = Date.now();
      roomData.size = SIZE;
      roomData.turn = "black"; // Winner (new black) goes first
      roomData.players = {
        black: newBlackPlayer,
        white: newWhitePlayer
      };
      roomData.moves = {};
      roomData.undoRequests = {};
      roomData.status = "playing"; // Reset status to playing
      // Keep owner
      // Note: winner field is not set/updated here

      return roomData;
    });

    // After transaction, update local role based on current room state
    const roomSnap = await get(roomRef);
    if (roomSnap.exists()) {
      const newRoomData = roomSnap.val();
      updateLocalRole(newRoomData.players);

      // Clear winning stones
      winningStones = [];

      showToast("Êñ∞Ê∏∏ÊàèÂºÄÂßãÔºÅËÉúÂà©ËÄÖÊâßÈªëÂÖàË°å");
    }
  }, 3000); // 3 seconds
}

/* ---------- Room lifecycle ---------- */
createBtn.onclick = async () => { const id = genCode(); roomInput.value = id; await createRoom(id); };
joinBtn.onclick = async () => { const id = roomInput.value.trim(); if(!id){ showToast("Enter a room code"); return;} await joinRoom(id); };
resetBtn.onclick = async () => {
  if(!roomId){ showToast("No active room"); return; }
  if (status && status.endsWith("-won")) { 
    showToast("Ê∏∏ÊàèÂ∑≤ÁªìÊùüÔºåÂç≥Â∞ÜËá™Âä®ÈáçÁΩÆ"); 
    return; 
  }
  
  // Get current players
  const roomRef = ref(db, `rooms/${roomId}`);
  const roomSnap = await get(roomRef);
  if (!roomSnap.exists()) return;
  
  const roomData = roomSnap.val();
  const players = roomData.players || {};
  
  // Reset room but keep current player assignments
  await set(roomRef, {
    createdAt: Date.now(),
    size: SIZE,
    turn: "black",
    players: players,
    moves: {},
    undoRequests: {},
    owner: localUID,
    status: "playing"
  });
  showToast("Ê£ãÁõòÂ∑≤ÈáçÁΩÆ");
};
leaveBtn.onclick = () => leaveRoom();

function genCode(){ return Math.random().toString(36).slice(2,8).toUpperCase(); }

async function createRoom(id){
  const rRef = ref(db, `rooms/${id}`);
  const snap = await get(rRef);
  if(snap.exists()){
    showToast("ÊàøÈó¥Â∑≤Â≠òÂú®ÔºåÊ≠£Âú®Âä†ÂÖ•‚Ä¶");
  } else {
    await set(rRef, {
      createdAt: Date.now(),
      size: SIZE,
      turn: "black",
      players: {},
      moves: {},
      undoRequests: {},
      owner: localUID,
      status: "playing"
    });
    showToast("ÊàøÈó¥ÂàõÂª∫ÊàêÂäü");
  }
  await joinRoom(id);
}

async function joinRoom(id){
  if(!localUID){ showToast("Not authenticated yet"); return; }
  roomId = id;
  const rRef = ref(db, `rooms/${roomId}`);
  const snap = await get(rRef);
  if(!snap.exists()){
    // Room doesn't exist, initialize it like createRoom
    await set(rRef, {
      createdAt: Date.now(),
      size: SIZE,
      turn: "black",
      players: {},
      moves: {},
      undoRequests: {},
      owner: localUID,
      status: "playing"
    });
    showToast("ÊàøÈó¥ÂàõÂª∫ÊàêÂäü");
  }


  // Keyboard handling for iOS PWA
let initialHeight = window.innerHeight;
const roomInput = document.getElementById('roomId');
const gameApp = document.getElementById('game-app');
const gameContent = document.querySelector('.game-content');

function adjustForKeyboard() {
  if (!window.visualViewport) return; // Fallback for older browsers

  const vh = window.visualViewport.height;
  const isKeyboardOpen = vh < initialHeight * 0.9; // Detect if height reduced >10% (keyboard threshold)

  if (isKeyboardOpen) {
    // Resize content to fit above keyboard
    gameApp.style.height = `${vh}px`;
    gameContent.style.height = `calc(${vh}px - 80px - env(safe-area-inset-top))`; // Adjust for header
    // Scroll input into view if needed
    roomInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } else {
    // Reset to full height
    gameApp.style.height = '100%';
    gameContent.style.height = 'calc(100% - 80px)';
  }
}

// Listen for viewport changes (keyboard open/close)
window.visualViewport.addEventListener('resize', adjustForKeyboard);
window.visualViewport.addEventListener('scroll', adjustForKeyboard);

// Also handle input focus/blur for smoother detection
roomInput.addEventListener('focus', () => {
  initialHeight = window.innerHeight;
  setTimeout(adjustForKeyboard, 150); // Small delay for keyboard animation
});
roomInput.addEventListener('blur', () => {
  setTimeout(() => {
    if (window.visualViewport.height >= initialHeight) {
      adjustForKeyboard();
    }
  }, 150);
});

// Initial setup
adjustForKeyboard();


  
  const playersRef = ref(db, `rooms/${roomId}/players`);
  let assigned = "spectator";
  await runTransaction(playersRef, p => {
    if(!p) p = {};
    if(!p.black){ p.black = localUID; assigned = "black"; }
    else if(!p.white && p.black !== localUID){ p.white = localUID; assigned = "white"; }
    else if(p.black === localUID) assigned = "black";
    else if(p.white === localUID) assigned = "white";
    else assigned = "spectator";
    return p;
  });
  role = assigned;
  
  // Set up disconnect cleanup for player slots
  if(role === "black" || role === "white") {
    onDisconnect(ref(db, `rooms/${roomId}/players/${role}`)).remove();
  }

  // unsubscribe previous
  if(unsubscribeRoom){ off(ref(db, `rooms/${roomId}`)); unsubscribeRoom = null; }

  // listen to room
  unsubscribeRoom = onValue(ref(db, `rooms/${roomId}`), snap => applyUpdate(snap.val()));
  status = "playing";
  updateStatus();
  renderBoard();
  showToast(`Joined as ${role}`);
  
  // Setup undo listeners
  setupUndoListener();
  setupUndoResponseListener();
  
  // UI toggle
  initialButtons.style.display = "none";
  inRoomButtons.style.display = "flex";
  fitBoardToViewport();
}

/* ---------- Enhanced leaveRoom with automatic cleanup ---------- */
async function leaveRoom(){
  if(!roomId) return;
  const thisRoom = roomId;

  try {
    if(role === "black" || role === "white"){
      // Clear player slot
      await set(ref(db, `rooms/${thisRoom}/players/${role}`), null);
      
      // Check if room should be deleted after a short delay
      setTimeout(() => {
        checkAndCleanupRoom(thisRoom);
      }, 1000); // 1 second delay to ensure Firebase syncs
    }
  } catch(err) {
    console.error("Failed to clear player slot on leave:", err);
  }

  // Remove realtime listener for this room
  if (unsubscribeRoom) {
    off(ref(db, `rooms/${thisRoom}`));
    unsubscribeRoom = null;
  }

  // Reset local state and UI
  roomId = null;
  role = null;
  status = "idle";
  roomOwner = null;
  lastMoveId = null;
  undoRequested = false;
  lastProcessedMoveId = null;
  winningStones = [];
  
  // Clear auto reset timer
  if (autoResetTimer) {
    clearTimeout(autoResetTimer);
    autoResetTimer = null;
  }

  // Clear local board and re-render empty board
  board = Array(SIZE).fill(null).map(()=>Array(SIZE).fill(null));
  renderBoard();
  updateStatus();

  // Reset UI controls to initial view
  initialButtons.style.display = "flex";
  inRoomButtons.style.display = "none";

  // Clear inputs / indicators
  roomInput.value = "";
  playersEl.textContent = "Áé©ÂÆ∂: -";
  turnEl.textContent = "ÂõûÂêà: ‚Äî";
  youEl.textContent = "‰Ω†ÁöÑËßíËâ≤: ‚Äî";
  statusEl.textContent = "ÂÆùÂÆùÊàëÁà±‰Ω†";

  showToast("Left room");
}

/* ---------- Enhanced checkWin function to return winning stones ---------- */
function checkWin(bd, r, c, color){ 
  if(!color) return false;
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dR,dC] of dirs){ 
    let stones = [{r, c}]; // Start with the current stone
    stones = stones.concat(countStones(bd, r, c, dR, dC, color));
    stones = stones.concat(countStones(bd, r, c, -dR, -dC, color));
    if(stones.length >= 5) {
      // Store the winning stones (take first 5)
      winningStones = stones.slice(0, 5);
      return true; 
    }
  }
  return false;
}

function countStones(bd, r, c, dR, dC, color){
  let i = 1, stones = [];
  while(true){
    const nr = r + dR * i, nc = c + dC * i;
    if(nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE || bd[nr][nc] !== color) break;
    stones.push({r: nr, c: nc});
    i++;
  }
  return stones;
}

/* ---------- Apply room updates from firebase ---------- */
async function applyUpdate(data){
  if(!data) {
    // Room was deleted (probably by cleanup)
    if (roomId) {
      showToast("Room has been closed");
      leaveRoom(); // Clean up local state
    }
    return;
  }
  
  // set owner if present
  if(data.owner) roomOwner = data.owner;
  else roomOwner = data.createdBy || null;

  // reset local board and load moves
  board = Array(SIZE).fill(null).map(()=>Array(SIZE).fill(null));
  if(data.moves){
    const moves = Object.values(data.moves).sort((a,b)=>a.ts-b.ts);
    moves.forEach(m=>{
      if(m && m.r!=null && !board[m.r][m.c]) board[m.r][m.c] = m.color;
    });
    
    // Update last move ID
    if (moves.length > 0) {
      const lastMove = moves[moves.length - 1];
      lastMoveId = { r: lastMove.r, c: lastMove.c, id: Object.keys(data.moves)[moves.length - 1] };
      
      // Play sound for opponent's moves
      const stoneSound = document.getElementById('stone-sound');
      if (lastMove.by !== localUID && lastMoveId.id !== lastProcessedMoveId && !stoneSound.muted) {
        playSoundImmediately(stoneSound);
        lastProcessedMoveId = lastMoveId.id;
      }
    } else {
      lastMoveId = null;
      lastProcessedMoveId = null;
    }
  } else {
    lastMoveId = null;
    lastProcessedMoveId = null;
  }
  
  // set turn from DB or derive
  turn = data.turn || getTurn(data.moves);
  
  // set local status to DB status if any
  status = data.status || "playing";
  
  // update players text
  const p = data.players || {};
  playersEl.textContent = `Players: black=${p.black||"‚Äî"} white=${p.white||"‚Äî"}`;

  // Update local role based on current player assignments
  updateLocalRole(p);

  renderBoard();

  // process latest move for win detection and turn updates
  const movesArr = data.moves ? Object.values(data.moves).sort((a,b)=>a.ts-b.ts) : [];
  if(movesArr.length){
    const last = movesArr[movesArr.length-1];
    const win = checkWin(board, last.r, last.c, last.color);
    if(win && (!data.status || !data.status.endsWith("-won"))){
      console.log("Game won by:", last.color);
      console.log("Winning stones:", winningStones);
      await update(ref(db, `rooms/${roomId}`), { status: last.color + "-won" });
      showToast(`üèÜ ${last.color.toUpperCase()} ËÉúÂà©‰∫ÜÔºÅ`);
      
      // Re-render board to show winning stones
      renderBoard();
      
      // Schedule automatic reset after 3 seconds
      scheduleAutoReset();
    } else if(!win){
      const next = last.color === "black" ? "white" : "black";
      if(data.turn !== next){
        await update(ref(db, `rooms/${roomId}`), { turn: next }).catch(()=>{});
      }
      if(localUID && role === next) showToast("ËΩÆÂà∞ÂÆùÂÆù‰∏ãÊ£ãÂï¶ÔºÅ");
    }
  }
  updateStatus();
  updateResetButton(); // Update reset button state
}

/* ---------- helper functions ---------- */
function getTurn(m){ if(!m) return "black"; const n = Object.keys(m).length; return n%2===0?"black":"white"; }

/* Update status text */
function updateStatus(){
  statusEl.textContent = (status === "playing") ? "Âú®ÊàøÈó¥‰∏≠" : (status && status.endsWith("-won") ? `Ended: ${status.replace("-won"," won")}` : "ÂÆùÂÆùÊàëÁà±‰Ω†");
}

/* initial render */
renderBoard();
fitBoardToViewport();

</script>

</body>
</html>
